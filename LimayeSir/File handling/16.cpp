int f(int ind,vector<int>&heights)
{
//     as n-1 to 0 jump hai top to bootom we have written base index 
    if(ind==0) return 0;
// left recursion call
    int left=
        
//         as will not always happen for ind
//         jump to 2nd stair
        int right=IND_MAX;
    if(ind>1) right=f(ind-2,heights)+abs()
}
int frogJump(int n, vector<int> &heights)
{
    //    Write your code here.
//     all possible ways--> recursion
//     count all ways -->best way select
//     here greedy soln will not work in some cases it will missed a way
//     1.index 2.do all stuff on that index 3.take the min
//     we have to find min energy required to reach (n-1)th from 0 index
//     as there is overlapping of some values hence use memorization
//     at 1st index there is no right recursion
//     recurrance-->DP
//     TC -->O(n)
//     recursion stack & array stack-->O(n)
    
}